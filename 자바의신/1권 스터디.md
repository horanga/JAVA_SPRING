상속과 구현의 차이
=============

#### 1. 상속과 구현은 각각 언제 사용하는가?
상속(extends)는 한 클래스가 다른 클래스로부터 상태(properties)와 메서드를 상속받는 것을 말한다. 부모 클래스를 base class라고 부르며, 이 base class로부터 상속을 받는 클래스를
derived or child class라고 부른다.

구현(implement)는 인터페이스를 구현하는 것을 말한다.(인터페이스는 추상 메서드로만 이뤄진 것을 말한다.)

두 개념 모두 상속과 관련이 있지만, 상속은 주로 특정 클래스의 기존 기능을 확장한다는 느낌이 강하고 구현은 '추상성'과 연관되며 일종의 계약(contract)와 관련이 있다고 한다.
계약이는 키워드는 인터페이스가 API를 명시해놓으면 그 계약 내용에 따라 다른 클래스들이 구현을 하기 때문이라고 이해했다.

두가지의 주요 차이점으로 
상속은 'is-a'이고, 인터페이스는 'can-do'라는 의견이 나온다.

강아지는 동물이다(Dog is Animal)처럼, 강아지 클래스는 동물 클래스를 상속할 수 있다. 이를 통해 부모 클래스의 메서드를 물려받아서 코드를 재사용 할 수 있고, 
부모 클래스의 메서드를 오버라이딩해서 확장할 수 있다.
상속은 주로 부모 클래스(동물이라는 뭉뚱그려진 개념)을 확장해서 '강아지'로 구체화하기 위해서 쓰는 것으로 이해했다.

인터페이스는 무언가를 할 수 있다(can do)의 느낌이다. 새는 날 수 있다(Bird can fly)에서는, 새가 클래스 Flyable이 인터페이스이다.
인터페이스는 주로 어떤 행동을 정의해놓고, 그 메서드들을 공유한다는 느낌으로 이해했다.

#### 2.추상화란 무엇인가?
일반적으로 추상화라고 하는 것은 주요 뼈대만 남기고, 덜 중요한 부분을 생략하는 과정을 말한다. 자바에서는 이 추상화가 조금 더 사용성에 초점이 맞춰져 있다.
가령, 메서드가 무슨 일을 할 수 있는지만 알리고, 그 과정이 어떻게 수행되는지는 숨긴다는 느낌이 강하다. 이러한 추상화는 인터페이스와 추상 클래스를 통해서 할 수 있다.
(추상화라고 하는 것은 전체 로직 혹은 시스템을 보다 쉽게 이해할 수 있도록 하기 위해서 하는 것인데, 자바에서도 그런 목적으로 사용하는 것 같다)


그렇다면, 추상화의 이점은?

공통된 행동을 추출해서 뽑아놓았기 때문에 이걸 기반으로 구현 클래스에서 메서드를 정의하면 된다.
(이 부분이 명확하게 이해하기 어렵지만, 내 생각엔 메서드 시그니쳐를 만들어서 이 규약을 모두 따르게 하기 위해서가 아닐까? 싶다. 그리고, 이렇게 한곳에 모아놓으면
그걸 관리하기도 쉽고)

또한, 다형성 측면에서도 좋다. 하나의 메서드 시그니처를 만들어 놓고 이걸 계속 확장할 수 있기 때문이다.
만약에, System.out.println()메서드를 String, double, int, long, float 각각 타입으로 모두 메서드를 시그니처를 다르게 해서 만들면 얼마나 불편할까?
(가령, 이름을 모두 다르게 한다던가..)
그런 불편함을 줄일 수 있도록, 메서드 오버라이딩을 통해서 같은 시그니처를 기반으로 인자만 변형할 수 있다. 인터페이스와 추상클래스도 이런 느낌이지 않을까 싶다.

#### 3. absract class의 생성자가 있으면 자식 클래스의 생성자는 어떻게 해야하는가?

우선, 추상 클래스는 생성자로 객체를 직접 만들 수 없다. 그렇다면, 생성자가 왜 필요한 것일까?
하위 클래스에서 공통적으로 가져야 할 특성들을 미리 지정해놓기 위해서다. 

추상 클래스에 생성자가 있으면, 자식 클래스는 추상 클래스의 생성자를 명시적으로 호출하는 것이 좋다.
만약, 추상 클래스에 기본 생성자가 아니라 매개변수를 받는 생성자가 있으면 자식 클래스에서는 반드시 이 생성자를 호출해야 한다. 

```java
abstract class Vehicle {
    protected String type;

    // 매개변수가 없는 기본 생성자
    public Vehicle() {
        this.type = "Unknown";
    }

    // 필수 속성을 초기화하는 생성자
    public Vehicle(String type) {
        this.type = type;
    }
}

class Car extends Vehicle {
    private String brand;

    // Car 클래스의 생성자에서 Vehicle 클래스의 매개변수가 있는 생성자를 호출
    public Car(String type, String brand) {
        super(type); // 명시적으로 상위 클래스의 매개변수가 있는 생성자 호출
        this.brand = brand;
    }
}

```

위 같은 경우는 매개변수가 없는 생성자가 있기 때문에 아래에 있는 생성자를 호출하지 않아도 되지만, 명시적으로 호출해주는 게 좋다.
이를 통해서 추상 클래스에 정의해놓은 '필수 속성(꼭 채워야 하는 것들)'을 채우도록 안전 장치를 만들 수 있다.


    
- 다중 상속이 안되는 이유
    
    다중 상속을 하면 어디에 소속되어 있는지 모름
    
- 인터페이스가 다중 구현이 가능한 이유
    
    인터페이스는 행위에 대한 것을 정의 따라서 다중 구현이 가능함
    
    어떠한 행위이기 때문
    
- 디폴트를 통해서 기본적인 내용을 담을 수 있음→ 인터페이스가 더 좋지 않냐
    
    abstract를 구현하는 것은
    
    반드시 모든 구현을 안해도 됨
    
    역할을 떠넘길 수 있음
    
    interface를 구현하는 클래스는 모든 메서드를 구현해야함
    
    인터페이스는 행위에 대한 것을 정의
    
- 자바 8에서 디폴트 메서드가 추가 된 이유가 무엇인가요

2. 객체지향이 무엇인지 설명해주세요 

현실세계를 모방해서 부품을 모듈화 시킴

- 객체와 클래스의 차이점
    
    클래스는 하나의 설계도
    상태와 행동이 있음
    
    객체는 그 클래스를 기반으로 해서 만듦
    
- 클래스와 인터페이스의 차이점
    
    클래스는 내용 바디가 나와 있는거
    인터페이스는 추상화된 것
    
- 오버로딩이 다형성인가?
    
    하나의 시그니쳐로 만들어 놓고 뻗어나가기 떄문에 다형성에 개념에 포함이 됨
    
- 4가지 특징
    
    다형성 등등 설명함
    
- 가장 중요한 원칙

3. String 클래스의 단점이 있다면 무엇일까요? 

재할당 마다 새로운 객체 생성

- Java 신버전에서 위 단점을 해결하였다 어떻게 해결되었나요?
    - 컴파일단계에서 StringBuilder 으로 변환된다. append() 메소드
    - 단, 반복문 내부에서는 해결 안됨.

- 몇 번의 수정이 일어났을 때 부터 유의미한 성능차이가 발생하나요?
    - 10~20번의 수정

- String의 불변성을 보장하기 위한 구조는, 변화를 전혀 할 수 없나요?
    - 새로운 객체를 만들기 때문에 불변을 보장한다.
    - reflection을 통해 수정될 수 있다 > 추가 조사 필요

- String은 참조자료형임에도 불구하고, 동일한 값을 갖는 두 객체(변수)에 == 연산의 결과가 True 입니다. 그 이유는 무엇일까요?
    - 둘다 string 리터럴인 경우에 true

- String tokenizer와 split의 차이
