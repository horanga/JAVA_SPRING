상속과 구현의 차이
=============

#### 1. 상속과 구현은 각각 언제 사용하는가?
상속(extends)는 한 클래스가 다른 클래스로부터 상태(properties)와 메서드를 상속받는 것을 말한다. 부모 클래스를 base class라고 부르며, 이 base class로부터 상속을 받는 클래스를
derived or child class라고 부른다.

구현(implement)는 인터페이스를 구현하는 것을 말한다.(인터페이스는 추상 메서드로만 이뤄진 것을 말한다.)

두 개념 모두 상속과 관련이 있지만, 상속은 주로 특정 클래스의 기존 기능을 확장한다는 느낌이 강하고 구현은 '추상성'과 연관되며 일종의 계약(contract)와 관련이 있다고 한다.
계약이는 키워드는 인터페이스가 API를 명시해놓으면 그 계약 내용에 따라 다른 클래스들이 구현을 하기 때문이라고 이해했다.

두가지의 주요 차이점으로 
상속은 'is-a'이고, 인터페이스는 'can-do'라는 의견이 나온다.

강아지는 동물이다(Dog is Animal)처럼, 강아지 클래스는 동물 클래스를 상속할 수 있다. 이를 통해 부모 클래스의 메서드를 물려받아서 코드를 재사용 할 수 있고, 
부모 클래스의 메서드를 오버라이딩해서 확장할 수 있다.
상속은 주로 부모 클래스(동물이라는 뭉뚱그려진 개념)을 확장해서 '강아지'로 구체화하기 위해서 쓰는 것으로 이해했다.

인터페이스는 무언가를 할 수 있다(can do)의 느낌이다. 새는 날 수 있다(Bird can fly)에서는, 새가 클래스 Flyable이 인터페이스이다.
인터페이스는 주로 어떤 행동을 정의해놓고, 그 메서드들을 공유한다는 느낌으로 이해했다.

+상속을 사용하면 여러 클래스에서 중복되는 메서드들을 부모클래스 한 곳에 정의해놓을 수 있다. 그러면 코드 중복을 줄일 수 있게 되고, 유지보수도 편해진다. 
또한, 상속을 통해서는 클래스 간의 계층적인 관계를 만들 수 있다. 계층 구조를 통해 설계가 더 체계화될 수 있다고 한다.

인터페이스는 다중 구현이 가능하다는 이점이 있다. 또한, 인터페이스를 사용하면 구현의 세부 사항을 추상화할 수 있다. 이를 통해서 시스템의 유연성을 향상시킬 수 있다.
(유연성 향상시키는 예시 추가)

#### 2.추상화란 무엇인가?
일반적으로 추상화라고 하는 것은 주요 뼈대만 남기고, 덜 중요한 부분을 생략하는 과정을 말한다. 자바에서는 이 추상화가 조금 더 사용성에 초점이 맞춰져 있다.
가령, 메서드가 무슨 일을 할 수 있는지만 알리고, 그 과정이 어떻게 수행되는지는 숨긴다는 느낌이 강하다. 이러한 추상화는 인터페이스와 추상 클래스를 통해서 할 수 있다.
(추상화라고 하는 것은 전체 로직 혹은 시스템을 보다 쉽게 이해할 수 있도록 하기 위해서 하는 것인데, 자바에서도 그런 목적으로 사용하는 것 같다)


그렇다면, 추상화의 이점은?

공통된 행동을 추출해서 뽑아놓았기 때문에 이걸 기반으로 구현 클래스에서 메서드를 정의하면 된다.
(이 부분이 명확하게 이해하기 어렵지만, 내 생각엔 메서드 시그니쳐를 만들어서 이 규약을 모두 따르게 하기 위해서가 아닐까? 싶다. 그리고, 이렇게 한곳에 모아놓으면
그걸 관리하기도 쉽고)

또한, 다형성 측면에서도 좋다. 하나의 메서드 시그니처를 만들어 놓고 이걸 계속 확장할 수 있기 때문이다.
만약에, System.out.println()메서드를 String, double, int, long, float 각각 타입으로 모두 메서드를 시그니처를 다르게 해서 만들면 얼마나 불편할까?
(가령, 이름을 모두 다르게 한다던가..)
그런 불편함을 줄일 수 있도록, 메서드 오버라이딩을 통해서 같은 시그니처를 기반으로 인자만 변형할 수 있다. 인터페이스와 추상클래스도 이런 느낌이지 않을까 싶다.

#### 3. absract class의 생성자가 있으면 자식 클래스의 생성자는 어떻게 해야하는가?

우선, 추상 클래스는 생성자로 객체를 직접 만들 수 없다. 그렇다면, 생성자가 왜 필요한 것일까?
하위 클래스에서 공통적으로 가져야 할 특성들을 미리 지정해놓기 위해서다. 

추상 클래스에 생성자가 있으면, 자식 클래스는 추상 클래스의 생성자를 명시적으로 호출하는 것이 좋다.
만약, 추상 클래스에 기본 생성자가 아니라 매개변수를 받는 생성자가 있으면 자식 클래스에서는 반드시 이 생성자를 호출해야 한다. 

```java
abstract class Vehicle {
    protected String type;

    // 매개변수가 없는 기본 생성자
    public Vehicle() {
        this.type = "Unknown";
    }

    // 필수 속성을 초기화하는 생성자
    public Vehicle(String type) {
        this.type = type;
    }
}

class Car extends Vehicle {
    private String brand;

    // Car 클래스의 생성자에서 Vehicle 클래스의 매개변수가 있는 생성자를 호출
    public Car(String type, String brand) {
        super(type); // 명시적으로 상위 클래스의 매개변수가 있는 생성자 호출
        this.brand = brand;
    }
}

```

위 같은 경우는 매개변수가 없는 생성자가 있기 때문에 아래에 있는 생성자를 호출하지 않아도 되지만, 명시적으로 호출해주는 게 좋다.
이를 통해서 추상 클래스에 정의해놓은 '필수 속성(꼭 채워야 하는 것들)'을 채우도록 안전 장치를 만들 수 있다.


#### 4.다중 상속이 안되는 이유[참고자료: Multiple Inheritance Conflict Resolution Rules (JAVA 8)](https://panditaarchit98.medium.com/multiple-inheritance-conflict-resolution-rules-java-8-82fb9fec0270)


다이아몬드 문제를 피하기 위해서다. A라는 클래스가 B와 C클래스를 모두 상속한다고 해보자. B와 C는 각각 eatFood()라는 메소드를 갖고 있다. 그렇다면, A 클래스의 개체가 eatFood()라는 메서드를 호출하면, B와 C의 메서드 중 어느것을 호출해야 할까? 컴파일 단계에서 이를 결정할 수 없다.

인터페이스는 왜 다중 구현이 가능할까? 인터페이스는 어차피 시그니쳐만 만들어놓는 곳이다. 바디는 구현 클래스에서 직접 채워넣는다. A클래스가 B와 C인터페이스를 구현한다고 해보자. B와 C에는 speak()이라는 메서드가 있다. A클래스의 개체가 speak이라는 메서드를 호출할 때, 어차피 B와 C 인터페이스의 메서드를 호출해도 바디가 없어서 결국 A클래스에 정의된 speak() 메서드를 호출해야 한다. 결국 다이아몬드 문제를 피할 수 있는 것이다.

*다만, 자바8에서는 인터페이스에 default method가 추가됐기 때문에 인터페이스에서도 바디를 직접 구현할 수 있게 됐다. 다중 상속 문제가 또 발생할 수 있게 된 것이다. 이를 어떻게 해결할 수 있을지 찾아보니 다음과 같은 자료가 있었다.

자바 8 디자이너들은 세가지 규칙을 만들었다고 한다.

규칙 1 클래스아 인터페이스보다 우선한다.
-클래스가 어떤 인터페이스의 디폴트 메서드와 같은 시그니처의 메서드를 상속받을 때 클래스 메서드가 우선한다. 
클래스 Demo가 인터페이스 A의 디폴트 메서드 print()와 클래스B의 print()메서드를 상속받으면, 클래스 B의 메서드가 실행된다.

규칙 2 파생된 인터페이스가 상위 인터페이스보다 우선한다.
-여러 인터페이스가 상속 체인에 있고, 같은 시그니처의 디폴트 메서드를 갖는다면 가장 하위의 인터페이스 메서드가 우선된다.
인터페이스 B가 A로부터 상속받고, 둘다 print()메서드를 갖는다고 해보자. 클래스 Demo가 B를 구현한다면 Demo에서 print()를 호출할 때 인터페이스 B의 메서드가 실행된다.

규칙3 충돌 시 클래스가 명시적으로 메서드를 오버라이드 해야 한다.
-위의 두 규칙으로 충돌이 해결되지 않는다면? 두개의 인터페이스가 동일한 레벨에서 같은 디폴트 메서드를 제공한다고 해보자. 이때 구현 클래스에서 이 메서드를 명시적으로 오버라이딩 해야 한다. 클래스 Demo가 인터페이스 A와 B를 구현하고, 이 두 인터페이스가 print() 메서드를 가지고 있다면 Demo는 자체적으로 print() 메서드를 제공해야 한다.

#### 5 자바 8에서 디폴트 메서드가 추가 된 이유가 무엇인가?

#### 6.추상클래스와 인터페이스 중 인터페이스가 더 좋은 것 아닌가?[참고자료:Abstract Class and Interface](https://medium.com/@omershafique/abstract-class-and-interface-45e734f3a8b)

우선,추상 클래스는 공통되는 부분을 모아서 추상 클래스에 정의하고, 그 외의 부분을 자식 클래스에서 확장하여 사용하는 개념으로 보면 좋다. 
인터페이스는 음료 주문, 제작, 고객 호출처럼 각각 카페마다 방식이 다른 경우에 적합하다. 공통적으로 뭔가 하는 대신 각자의 방식대로 같은 목적을 달성한다면 인터페이스가 적합하다.(논리적으로 인터페이스는 관련성이 별로 없는 클래스들을 묶기에도 좋다)

추상 클래스를 사용하면 좋을 때는

-여러 클래스가 중복되는 코드가 있을 때
-non-static/non-final필드를 선언해서 개체의 상태를 관리할 때
-public 이외의 접근 제어자(protected, private 등)가 필요할 때
-메서드가 자주 변경되는 경우, 인터페이스보다 추상 클래스가 유리하다. 추상 클래스를 사용하면 새 메서드에 대한 기본 구현을 제공할 수 있으며, 이를 사용하는 하위 클래스만 변경하면 된다(추상 클래스에서만 내용을 변경하면 되니까!)
-일부 메서드의 구현을 직접 제공할 때(위 내용이랑 조금 겹친다)

인터페이스를 사용하면 좋을 때는

-전체 메서드를 추상화할 때
-특정 행동을 지정하고 싶은데, 누가 그 행동을 구현하는지는 관심 없을 때
-다중 상속이 필요할 때

객체지향이란?
=============
    
#### 1.객체지향이 무엇인지 설명해주세요 [참고자료:인파님 블로그](https://inpa.tistory.com/entry/OOP-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EA%B0%9C%EB%85%90%EA%B3%BC-%EC%B6%94%EC%83%81%ED%99%94-%EC%84%A4%EA%B3%84%EC%9D%98-%EC%9D%B4%ED%95%B4)

객체 지향이란 여러 개체들이 모여서 상호 작용해 데이터를 처리하는 프로그래밍 설계 기법을 뜻한다.

프로그램을 묶음 단위로 잘게 쪼갠 뒤 만들어 놓으면, 나중에 필요할 때마다 이걸 가져와서 쓸 수 있다.
레고블럭을 조립하듯이 전체 조립중에서 불필요한 것을 빼고, 새로운 것을 껴고.. 이런 방식으로 현업 대규모 소프트웨어 개발에 많이 쓰인다.

자바의 class는 서로 연관된 함수와 변수를 모아서 박스에 넣어놓은 개념이라고 볼 수 있다. 이런 클래스를 중심으로 프로그램의 구조를 만드는 것이 객체 지향 프로그래밍이다.


#### 2.객체 지향의 네가지 특징은? [참고자료:코드스테이츠 자료](https://www.codestates.com/blog/content/%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%ED%8A%B9%EC%A7%95)

1)추상화 

객체의 공통적인 속성과 기능을 정의하는 것을 말한다.
자동차와 오토바이는 이동수단이다. 전진과 후진을 할 수 있다는 공통점이 있다. 

이를 클래스로 표현하면, 이동수단이라는 상위 클래스와 자동차와 오토바이는 하위 클래스 그리고 전진과 후진이라는 공통 기능으로 추출할 수 있다.
자바에서는 추상화를 구현할 때 추상클래스와 인터페이스를 사용한다.
(인터페이스는 추상 메서드나 상수를 통해서 어떤 객체가 수행할 핵심적인 역할만 규정하고, 실제 구현은 인터페이스를 구현한 각각의 객체에게 넘긴다)

2)상속

상속은 기존의 클래스를 재활용해서 새로운 클래스에 적용하는 것을 말한다.

이동수단이라는 상위 클래스에 공통된 속성과 기능을 정의해보자. 그런 다음, 자동차와 오토바이가 이동수단을 상속하게 하면, 상위 클래스의 속성과 기능을 편하게 쓸 수 있다.
상속을 활용하면 여러 클래스가 공유하는 속성과 기능을 중복해서 정의할 필요 없이, 상위 클래스에만 정의해놓은 다음에 사용할 수 있다. 상위 클래스에 공통 기능과 속성을 모아두기 때문에, 유지보수 할 때 상위 클래스만 변경해도 하위 클래스에도 다 적용할 수 있다는 이점이 있다.


*상속은 인터페이스에 비해서 추상화의 정도가 낮은 편이다. 인터페이스는 껍데기만 정의하고 하위 클래스에 구현을 맡기지만, 상속은 상황에 따라 모든 구체저인 내용을 정의해두고 하위 클래스에서 그것을 단순히 가져가 재사용하기 때문.


3)다형성

다형성이란 어떤 객체의 속성이나 기능이 상황에 따라 여러 가지 형탤르 가질 수 있는 성질을 의미한다.

인터페이스에서 껍데기를 정의해놓고, 이걸 다양한 방식으로 구현하는 것이 다형성의 한 사례다.

상속 역시 대표적인 다형성의 사례다. 이동수단이라는 상위 클래스가 있고, 하위 수단에 자동차와 오토바이가 있다.

그러면, 

```java
Vehicle[] vehicles = new Vehicle[2];
vehicles[0] = new Bike();
vehicles[1] = new Car();

public 메서드1(Vechicle p);//생략

Bike a = new Bike();
Car b = new Car();
메서드1(a);
메서드1(b);
```

같은 관계가 성립될 수 있는 것이다.
Vehicle타입의 개체를 받아야 하는 상황일 때, 이 클래스의 하위 클래스 개체들을 모두 받을 수 있다.
덕분에 하위 클래스의 개체들마다 일일이 메서드를 작성하거나, 배열을 만들 필요가 없어진다.

4)캡슐화
캡슐화는 클래스 안에 서로 연관있는 속성과 기능을 하나의 캡슐로 만드는 것을 말한다. 이를 통해서 데이터를 외부로부터 보호할 수 있다는 이점이 ㅅㅇ긴다.

```java

public class Car{

private int speed;

public printSpeend(){
System.out.println(speed);
}

public speedUp(){
speed +=10;
}

public speedDown(){
speed -=10;
}
}
```

이런 클래스를 만들고, Car의 개체들을 사용한다고 해보자.
speed를 private으로 선언했기 때문에 외부에서

car.speed= 30; 처럼 직접 데이터를 조작하지 못한다.

(car, drive 모듈사용 예시 추가하기)

#### 3. 오버로딩이 다형성인가?[참고자료: Java Polymorphism](https://javapapers.com/core-java/java-polymorphism/)

자바에서 다형성은 하나의 액션을 다양한 방식으로 행할 수 있도록 허용한다. 쉽게 말하면, 인터페이스 하나를 만들어놓고 다양한 구현체를 만들 수 있다는 것이다.
개인적으로 오버로딩은 다형성에 속한다고 생각한다. 하나의 시그니처를 만들어 놓고 인자만 다르게 해서 구현체를 바꾸기 때문이다.
다만, 오버로딩이 다형성에 속하는지는 의견이 분분하다고 한다. 

참고 자료에 따르면, 다형성은 오버로딩 그 이상의 개념을 포괄하는 것이다. 오버라이딩, 제네릭스 등을 통해서 이룰 수 있는것이지 오버로딩==다형성이라고 볼 수는 없는 듯하다. 
    
    
- 가장 중요한 원칙

3. String 클래스의 단점이 있다면 무엇일까요? 

재할당 마다 새로운 객체 생성

- Java 신버전에서 위 단점을 해결하였다 어떻게 해결되었나요?
    - 컴파일단계에서 StringBuilder 으로 변환된다. append() 메소드
    - 단, 반복문 내부에서는 해결 안됨.

- 몇 번의 수정이 일어났을 때 부터 유의미한 성능차이가 발생하나요?
    - 10~20번의 수정

- String의 불변성을 보장하기 위한 구조는, 변화를 전혀 할 수 없나요?
    - 새로운 객체를 만들기 때문에 불변을 보장한다.
    - reflection을 통해 수정될 수 있다 > 추가 조사 필요

- String은 참조자료형임에도 불구하고, 동일한 값을 갖는 두 객체(변수)에 == 연산의 결과가 True 입니다. 그 이유는 무엇일까요?
    - 둘다 string 리터럴인 경우에 true

- String tokenizer와 split의 차이

Java 예외의 종류에는 무엇이 있나요? ()

- 두개, 체크, 언체크
- 체크는 컴파일 때 걸림, 언체크는 안걸림
- 에러는? 오류다. 오류안에 에러있음
- 오류와 에러의 차이는? 오류는 프로그램 외, 에러는 프로그램 내
- 오류는 처리가능? 못함.
- 언제 체크예외?언제 언체크 예외? 전자는 디비문제 후자는 배열범위 넘었을 때 같은 경우
- 예외를 조심해서 써야하나? 네. 파이프라인이 깨진다.
- 예외를 프린트스택하면 생기는 문제? 예외 스택을 다 따라가야하는 오버헤드가 발생. 메시지 출력도 너무 많음. 해결책 getstacktrace
- 작은 예외부터 잡는 이유는? 앞에서 답아주지 못한 예외를 잡기 위해
- 커스첨 예외 만드는 방법? 예외 상속받기.
- 커스텀 예외를 써야할까?아니면 기본 예외흫 써야할까? 전자는 명시적이다.
- 인자가 널일 때, NPE, ISE 뭘 쓸까? 전자는 널 자체로 인한 문제이므로 전자가 더 맞다.

 static 키워드에 대해 설명해주세요(상화)

- 자원을 클래스 레벨로 관리할 수 있게 된다. static은 내부 클래스의 경우에만 붙을 수 있음.
- static 메서드는 인스턴스가 없어서 인스턴스 변수에 접근할 수 없다.
- static 블록은 클래스가 jvm이 시작되는 순간에만 시작된다. 클래스 초기화 목적
- static 변수 사용에 주의해야 하는 이유는? 객체마다 상태를 갖게 된다. 객체들이 같은 static 상태를 공유하게 된다. 어느 쪽에서 변경을 시도하면 예상치 못한 결과가 나올 수 있다. 사람 클래스의 age를 static으로 정의하면 개별적인 개체의 상태를 저장할 수 없다.
- 메인 메서드에 static이 붙는 이유는 클래스의 객체가 있어야 하는데, 메인 메서드의 객체가 없기 떄문에.
- import에 static이 붙는 이유는? 파일 명을 생략해도 된다.
- static 을 쓰는 이유는? 공통된 정보기 때문에 모두 개별적인 변수를 만들 필요가 없을 것이다.
-
-
-    Call by reference, call by value는 어떻게 다를까요?

- 메서드에 값을 전달한다. value는 값을 복사해서 전달한다 . refer는 참조를 넘기는 방식이다.
- 자바에서는 call by refer가 존재하지 않는다. 값의 참조를 넘기는 것이지 heap 영역의 주소값을 전달하는 것이 아니다. stack의 주소값을 넘기는 것.
- call by refer의 단점은? 실제 개체의 메모리에 접근 가능하고, 여러 곳에서 접근할 수 있다는 것은 값을 보장할 수 없다.
- String은 call by value(refer가 없음)
- 자바는 왜 pass by value로만 설계가 됐는지. 메모리에 직접 접근하는 것은 위험하다. 메모리 주소를 다룰 수가 없다. 불편함이라면 메모리를 할당하는 과정, 메모리를 반환하는 과정이 있어야 하는데 그게 귀찮음
- 실제 객체는 heap에 있고 참조변수는 heap 있는 개체의 주소를 가리킨다.
- 클래스 안에 있는 변수들이 메모리상에서 연속적인가?
    
    가상메모리
  
어노테이션에 대해 설명해주세요?
컴파일러에게 알려주는 것

override : 메소드 시그니처를 지킬 수 있도록

deprecated : 더이상 사용하지 않음을 컴파일러에게

- 메타 어노테이션에 대해 알고 계신게 있나요?
    
    E.g.) Target
    

- 런타임 시점에서 어노테이션을 알 수 있나요?

- 커스텀 어노테이션이란 무엇인가요?
    
    @interface 어노테이션을 사용해 생성
    

- 어노테이션은 상속이 될까요?

 nested class가 뭔가요?

- 클래스 안의 클래스, 스태틱, 이너. 논리적 모듈을 형성
- 스태틱 키뤄드 붙는 이유. 인스턴스 화 없이 사용하려고
- 메서드 안에서 클래스 정의 가능한가? ㅇㅇ
- 메서드 안에서 클래스 정의를 ㅘ는 이유. 파일 안만들어도 됨. 가독성.
- 익명클래스는 일반 클래스와 동일하게 컴파일 될까? $표시 붙는다?
- 익명클래스를 어떻게 만들어지나요?
- 람다는 익명클래스인가요?
</aside>
