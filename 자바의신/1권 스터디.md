상속과 구현의 차이
=============

#### 1. 상속과 구현은 각각 언제 사용하는가?
상속(extends)는 한 클래스가 다른 클래스로부터 상태(properties)와 메서드를 상속받는 것을 말한다. 부모 클래스를 base class라고 부르며, 이 base class로부터 상속을 받는 클래스를
derived or child class라고 부른다.

구현(implement)는 인터페이스를 구현하는 것을 말한다.(인터페이스는 추상 메서드로만 이뤄진 것을 말한다.)

두 개념 모두 상속과 관련이 있지만, 상속은 주로 특정 클래스의 기존 기능을 확장한다는 느낌이 강하고 구현은 '추상성'과 연관되며 일종의 계약(contract)와 관련이 있다고 한다.
계약이는 키워드는 인터페이스가 API를 명시해놓으면 그 계약 내용에 따라 다른 클래스들이 구현을 하기 때문이라고 이해했다.

두가지의 주요 차이점으로 
상속은 'is-a'이고, 인터페이스는 'can-do'라는 의견이 나온다.

강아지는 동물이다(Dog is Animal)처럼, 강아지 클래스는 동물 클래스를 상속할 수 있다. 이를 통해 부모 클래스의 메서드를 물려받아서 코드를 재사용 할 수 있고, 
부모 클래스의 메서드를 오버라이딩해서 확장할 수 있다.
상속은 주로 부모 클래스(동물이라는 뭉뚱그려진 개념)을 확장해서 '강아지'로 구체화하기 위해서 쓰는 것으로 이해했다.

인터페이스는 무언가를 할 수 있다(can do)의 느낌이다. 새는 날 수 있다(Bird can fly)에서는, 새가 클래스 Flyable이 인터페이스이다.
인터페이스는 주로 어떤 행동을 정의해놓고, 그 메서드들을 공유한다는 느낌으로 이해했다.

#### 2.추상화란 무엇인가?
일반적으로 추상화라고 하는 것은 주요 뼈대만 남기고, 덜 중요한 부분을 생략하는 과정을 말한다. 자바에서는 이 추상화가 조금 더 사용성에 초점이 맞춰져 있다.
가령, 메서드가 무슨 일을 할 수 있는지만 알리고, 그 과정이 어떻게 수행되는지는 숨긴다는 느낌이 강하다. 이러한 추상화는 인터페이스와 추상 클래스를 통해서 할 수 있다.
(추상화라고 하는 것은 전체 로직 혹은 시스템을 보다 쉽게 이해할 수 있도록 하기 위해서 하는 것인데, 자바에서도 그런 목적으로 사용하는 것 같다)


그렇다면, 추상화의 이점은?

공통된 행동을 추출해서 뽑아놓았기 때문에 이걸 기반으로 구현 클래스에서 메서드를 정의하면 된다.
(이 부분이 명확하게 이해하기 어렵지만, 내 생각엔 메서드 시그니쳐를 만들어서 이 규약을 모두 따르게 하기 위해서가 아닐까? 싶다. 그리고, 이렇게 한곳에 모아놓으면
그걸 관리하기도 쉽고)

또한, 다형성 측면에서도 좋다. 하나의 메서드 시그니처를 만들어 놓고 이걸 계속 확장할 수 있기 때문이다.
만약에, System.out.println()메서드를 String, double, int, long, float 각각 타입으로 모두 메서드를 시그니처를 다르게 해서 만들면 얼마나 불편할까?
(가령, 이름을 모두 다르게 한다던가..)
그런 불편함을 줄일 수 있도록, 메서드 오버라이딩을 통해서 같은 시그니처를 기반으로 인자만 변형할 수 있다. 인터페이스와 추상클래스도 이런 느낌이지 않을까 싶다.

#### 3. absract class의 생성자가 있으면 자식 클래스의 생성자는 어떻게 해야하는가?

우선, 추상 클래스는 생성자로 객체를 직접 만들 수 없다. 그렇다면, 생성자가 왜 필요한 것일까?
하위 클래스에서 공통적으로 가져야 할 특성들을 미리 지정해놓기 위해서다. 

추상 클래스에 생성자가 있으면, 자식 클래스는 추상 클래스의 생성자를 명시적으로 호출하는 것이 좋다.
만약, 추상 클래스에 기본 생성자가 아니라 매개변수를 받는 생성자가 있으면 자식 클래스에서는 반드시 이 생성자를 호출해야 한다. 

```java
abstract class Vehicle {
    protected String type;

    // 매개변수가 없는 기본 생성자
    public Vehicle() {
        this.type = "Unknown";
    }

    // 필수 속성을 초기화하는 생성자
    public Vehicle(String type) {
        this.type = type;
    }
}

class Car extends Vehicle {
    private String brand;

    // Car 클래스의 생성자에서 Vehicle 클래스의 매개변수가 있는 생성자를 호출
    public Car(String type, String brand) {
        super(type); // 명시적으로 상위 클래스의 매개변수가 있는 생성자 호출
        this.brand = brand;
    }
}

```

위 같은 경우는 매개변수가 없는 생성자가 있기 때문에 아래에 있는 생성자를 호출하지 않아도 되지만, 명시적으로 호출해주는 게 좋다.
이를 통해서 추상 클래스에 정의해놓은 '필수 속성(꼭 채워야 하는 것들)'을 채우도록 안전 장치를 만들 수 있다.


    
- 다중 상속이 안되는 이유
    
    다중 상속을 하면 어디에 소속되어 있는지 모름
    
- 인터페이스가 다중 구현이 가능한 이유
    
    인터페이스는 행위에 대한 것을 정의 따라서 다중 구현이 가능함
    
    어떠한 행위이기 때문
    
- 디폴트를 통해서 기본적인 내용을 담을 수 있음→ 인터페이스가 더 좋지 않냐
    
    abstract를 구현하는 것은
    
    반드시 모든 구현을 안해도 됨
    
    역할을 떠넘길 수 있음
    
    interface를 구현하는 클래스는 모든 메서드를 구현해야함
    
    인터페이스는 행위에 대한 것을 정의
    
- 자바 8에서 디폴트 메서드가 추가 된 이유가 무엇인가요

2. 객체지향이 무엇인지 설명해주세요 

현실세계를 모방해서 부품을 모듈화 시킴

- 객체와 클래스의 차이점
    
    클래스는 하나의 설계도
    상태와 행동이 있음
    
    객체는 그 클래스를 기반으로 해서 만듦
    
- 클래스와 인터페이스의 차이점
    
    클래스는 내용 바디가 나와 있는거
    인터페이스는 추상화된 것
    
- 오버로딩이 다형성인가?
    
    하나의 시그니쳐로 만들어 놓고 뻗어나가기 떄문에 다형성에 개념에 포함이 됨
    
- 4가지 특징
    
    다형성 등등 설명함
    
- 가장 중요한 원칙

3. String 클래스의 단점이 있다면 무엇일까요? 

재할당 마다 새로운 객체 생성

- Java 신버전에서 위 단점을 해결하였다 어떻게 해결되었나요?
    - 컴파일단계에서 StringBuilder 으로 변환된다. append() 메소드
    - 단, 반복문 내부에서는 해결 안됨.

- 몇 번의 수정이 일어났을 때 부터 유의미한 성능차이가 발생하나요?
    - 10~20번의 수정

- String의 불변성을 보장하기 위한 구조는, 변화를 전혀 할 수 없나요?
    - 새로운 객체를 만들기 때문에 불변을 보장한다.
    - reflection을 통해 수정될 수 있다 > 추가 조사 필요

- String은 참조자료형임에도 불구하고, 동일한 값을 갖는 두 객체(변수)에 == 연산의 결과가 True 입니다. 그 이유는 무엇일까요?
    - 둘다 string 리터럴인 경우에 true

- String tokenizer와 split의 차이

Java 예외의 종류에는 무엇이 있나요? ()

- 두개, 체크, 언체크
- 체크는 컴파일 때 걸림, 언체크는 안걸림
- 에러는? 오류다. 오류안에 에러있음
- 오류와 에러의 차이는? 오류는 프로그램 외, 에러는 프로그램 내
- 오류는 처리가능? 못함.
- 언제 체크예외?언제 언체크 예외? 전자는 디비문제 후자는 배열범위 넘었을 때 같은 경우
- 예외를 조심해서 써야하나? 네. 파이프라인이 깨진다.
- 예외를 프린트스택하면 생기는 문제? 예외 스택을 다 따라가야하는 오버헤드가 발생. 메시지 출력도 너무 많음. 해결책 getstacktrace
- 작은 예외부터 잡는 이유는? 앞에서 답아주지 못한 예외를 잡기 위해
- 커스첨 예외 만드는 방법? 예외 상속받기.
- 커스텀 예외를 써야할까?아니면 기본 예외흫 써야할까? 전자는 명시적이다.
- 인자가 널일 때, NPE, ISE 뭘 쓸까? 전자는 널 자체로 인한 문제이므로 전자가 더 맞다.

 static 키워드에 대해 설명해주세요(상화)

- 자원을 클래스 레벨로 관리할 수 있게 된다. static은 내부 클래스의 경우에만 붙을 수 있음.
- static 메서드는 인스턴스가 없어서 인스턴스 변수에 접근할 수 없다.
- static 블록은 클래스가 jvm이 시작되는 순간에만 시작된다. 클래스 초기화 목적
- static 변수 사용에 주의해야 하는 이유는? 객체마다 상태를 갖게 된다. 객체들이 같은 static 상태를 공유하게 된다. 어느 쪽에서 변경을 시도하면 예상치 못한 결과가 나올 수 있다. 사람 클래스의 age를 static으로 정의하면 개별적인 개체의 상태를 저장할 수 없다.
- 메인 메서드에 static이 붙는 이유는 클래스의 객체가 있어야 하는데, 메인 메서드의 객체가 없기 떄문에.
- import에 static이 붙는 이유는? 파일 명을 생략해도 된다.
- static 을 쓰는 이유는? 공통된 정보기 때문에 모두 개별적인 변수를 만들 필요가 없을 것이다.
-
-
-    Call by reference, call by value는 어떻게 다를까요?

- 메서드에 값을 전달한다. value는 값을 복사해서 전달한다 . refer는 참조를 넘기는 방식이다.
- 자바에서는 call by refer가 존재하지 않는다. 값의 참조를 넘기는 것이지 heap 영역의 주소값을 전달하는 것이 아니다. stack의 주소값을 넘기는 것.
- call by refer의 단점은? 실제 개체의 메모리에 접근 가능하고, 여러 곳에서 접근할 수 있다는 것은 값을 보장할 수 없다.
- String은 call by value(refer가 없음)
- 자바는 왜 pass by value로만 설계가 됐는지. 메모리에 직접 접근하는 것은 위험하다. 메모리 주소를 다룰 수가 없다. 불편함이라면 메모리를 할당하는 과정, 메모리를 반환하는 과정이 있어야 하는데 그게 귀찮음
- 실제 객체는 heap에 있고 참조변수는 heap 있는 개체의 주소를 가리킨다.
- 클래스 안에 있는 변수들이 메모리상에서 연속적인가?
    
    가상메모리
  
어노테이션에 대해 설명해주세요?
컴파일러에게 알려주는 것

override : 메소드 시그니처를 지킬 수 있도록

deprecated : 더이상 사용하지 않음을 컴파일러에게

- 메타 어노테이션에 대해 알고 계신게 있나요?
    
    E.g.) Target
    

- 런타임 시점에서 어노테이션을 알 수 있나요?

- 커스텀 어노테이션이란 무엇인가요?
    
    @interface 어노테이션을 사용해 생성
    

- 어노테이션은 상속이 될까요?

 nested class가 뭔가요?

- 클래스 안의 클래스, 스태틱, 이너. 논리적 모듈을 형성
- 스태틱 키뤄드 붙는 이유. 인스턴스 화 없이 사용하려고
- 메서드 안에서 클래스 정의 가능한가? ㅇㅇ
- 메서드 안에서 클래스 정의를 ㅘ는 이유. 파일 안만들어도 됨. 가독성.
- 익명클래스는 일반 클래스와 동일하게 컴파일 될까? $표시 붙는다?
- 익명클래스를 어떻게 만들어지나요?
- 람다는 익명클래스인가요?
</aside>
